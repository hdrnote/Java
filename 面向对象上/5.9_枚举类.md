# 枚举类

在某些情况下,一个类的对象是有限而且固定的,例如季节,他只有四个对象.

这种实例有限而且固定的类,就叫做枚举类.

## 手动实习枚举类

在早期代码中,会使用静态常量来表示枚举.

```java
public static final int SEASON_SPRING = 1;
```

这种定义简单明了,但是存在如下问题.

① 类型不安全:例如上面的季节是个int类型,那么你就可以对它进行+- 那这是不合理的.

② 没有命令空间:当需要用到季节时,必须加上它的类名.

③ 打印输出的意义不明确.

## 枚举类入门

定义枚举类

```java
[public] enum classname{}
```

### 枚举类与其他类的区别

① enum定义的枚举类默认继承了java.lang.Enum类,因此不能显式继承其他父类.

② 非抽象的枚举类没自动被final修饰,因此非抽象枚举类不能被继承.

③ 枚举类的构造器只能使用private访问控制符修饰.

④ 枚举类的所有实例必须在枚举类的第一行显式列出,否则这个枚举类永远都不能产生实例.

⑤ 这些实例自动会被public static final 修饰

```java
public enum SeasonEnum
{
    SPRING,SUMMER,FALL,WINTER; //列出实例  自动会被public static final修饰
}
```

使用枚举类的某个实例, SeansonEnum.SPRING.

**java.lang.Enum类提供了下面几个方法**

int compareTo(E o):该方法用于与指定枚举对象比较顺序,如果位于指定枚举对象的后面则返回正数,否则负数.

int orinal(): 返回枚举类的索引

String toString() 返回枚举类的名称.

public static <T extends Enum<T>>T valueOf(Class<T>enumType,String name):

## 枚举类的成员变量、方法和构造器

## 实现接口的枚举类

如果由枚举类来实现接口的方法,则每个枚举值在调用该方法时都有相同的行为,因为方法体是相同的.

如果需要不同的枚举类调用相同的方法,但是却有不同的行为,则可以让每个枚举类分别实现接口方法.

```java
interface GenderDesc {
	void info();
}

enum Gender implements GenderDesc {
	MALE("男") {
		public void info() {
			System.out.println("我是男的");
		}
	}, // 注意这里用的是逗号 MALE,FEMALE;
	FEMALE("女") {
		public void info() {
			System.out.println("我是女的");
		}
	};

	private final String name;

	// 构造器
	private Gender(String name) {
		this.name = name;
	}
	
	public String getName()
	{
		return this.name;
	}
}

public class Demo {
	// --------------------------------------
	public static void main(String[] args) {
		Gender man = Gender.MALE;
		System.out.println(man.getName());
		man.info();
		
	}
}
```

## 包含抽象方法的枚举类

我个人理解,SeasonEnum是枚举类, SPRING SUMMER 等等其实是内部类.

还是上面的例子,不过我们不用接口了,而是在枚举类里面定义一个抽象方法,让枚举类的内部类实现这个抽象方法.