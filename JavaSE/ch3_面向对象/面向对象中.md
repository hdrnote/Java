## 继承

*继承*是从已有的类中派生出新的类，新的类具有被继承类的数据属性和行为，并能扩展新的能力。

### 语法

```java
[修饰符] class SubClass extends SuperClass{
 	// 类定义部分   
}
```

### 重写父类的方法



### super限定

如果需要在子类方法中,调用父类被覆盖的方法,则可以使用super关键字

```java
super() // 调用父类构造器
super.overridedMethod();
```

----

## 抽象类

**定义：**abstract关键字修饰的，包含一个到多个抽象方法（没有方法体的方法）的类。

**作用：**只是定义这个类具有哪些功能，具体这些功能的实现，由继承的它的类所实现，让人只注重它具有的功能而不用了解其实现方法，增加了代码的可读性。

**存在的意义**：在某些情况下，类会无法确定其方法的实现方式，
例如图形类，它要计算周长，但是不同的图形有不同的周长公式，
那就导致图形类无法确定计算周长这个方法的实现方式。
这个时候使用抽象类就是个不错的解决方法。

**注意事项：**

- 抽象类里面可以有普通方法
- 抽象类的继承类必须实习抽象类的所有抽象方法，否则这个继承类也只能定义为抽象类

----

## 接口

**语法：**

```java
[修饰符] interface 接口名称{}
```

**什么是接口？：**接口是类的蓝图，它只有**静态常量**和**抽象方法**

**作用：**定义一组抽象方法，让具体的类去实现，让人只注重它具有的功能而不用了解其实现方法，增加了代码的可读性。

----

## 抽象类VS接口

看完了抽象类和接口，你可能发现，抽象类与接口似乎都具有相同的功能，抽象类明明可以代替接口，为什么还要有接口呢？

**这就要从类和接口说起**

最初，人们并不知道“面向对象”究竟应该是什么、“继承”又该占据什么位置——对一种新生事物，要求人们一下子就在头脑里有个清晰图景显然是不可能的。

关于面向对象，一直以来就有两个主要派别：Class-based vs Prototype-based。

**Class-based派**认为，面向对象就是个分类问题；既然是分类问题，那么根据生活经验，更靠“上”更“抽象”的大类自然就更基础，它所有的东西理所当然应该被继续细化的“子”类“继承”——圆形是个图形，方形也是个图形，所以圆形和方形都应该从“图形”这个类继承。 这个想法看上去很不错很靠谱，所以Object C、C++、Java全都选择了这条路。 

但是这种想法很容易直接导向一个误区，那就是不假思索的引入“继承”，并且还总是把“继承”看得过重。而且它“默认让派生类取得基类所有遗产”的行为造成了很多的问题——这种行为不可避免的导致派生类和基类代码产生耦合； 

**Prototype-based派**则认为，面向对象其实就是一组实现了特定协议（或者叫接口）的object——在它里面压根就不存在类，只有prototype和object。我们真正应该关心的是“对象可以提供什么样的服务”：重要的是接口！压根就不需要考虑/支持继承这种矫揉造作的东西！ 

当然我们程序员是很包容的人，所以几乎从最初的几个版本开始Java就引入了prototype流派的思想，这就是所谓的“interface” 。

**注意：class在编程中的意思其实是“is-a” （是什么）”  跟翻译过来“类”其实八竿子都打不着。**

class Dog  （是狗）

class  Shiba extends Dog （是柴犬 是狗）

**总结：类与接口是两大流派，抽象类是类流派用来弥补自身理论缺陷的工具**

----

## Final关键字

final 翻译为最终，每一次变动就是一次后续，final就是没有后续，也就是不会再有变动。

final关键字的作用

- 使用final关键字修饰变量
  - final修饰的变量会变成常量，顾名思义就是不变的量 （常量的命名为全大写）
  - final修饰的变量，只能进行一次赋值
    - final修饰的局部变量可以先定义后赋值
    - final修饰的成员变量不能先定义后赋值（因为类和对象创建时，成员变量会有默认值）
- 使用final关键字修饰方法
- 使用final关键字修饰类
- 使用final关键字修饰方法参数

----

## 

## 多态

Java引用变量有两种类型,一种是编译时类型,一种是运行时类型.

多态就是指:引用变量的编译时类型跟运行时类型不一致.

```java
Father person = new Son();
// person 的编译时类型是Father 运行时类型是Son.
// 注意 编译时类型是运行时类型的父类
```

**注意:**

1. 实例方法具有多态性,实例变量不具有多态性
2. 如果调用的运行时类型的方法,是编译时类型所不具备的,则会报错.
3. 一般来说,多态其实就是用于接口/或抽象类上.

